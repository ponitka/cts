{"version":3,"sources":["../../../../src/common/framework/query/parseQuery.ts"],"names":["badParamValueChars","paramKeyIsPublic","assert","parseParamValue","TestQueryMultiFile","TestQueryMultiTest","TestQueryMultiCase","TestQuerySingleCase","kBigSeparator","kWildcard","kPathSeparator","kParamSeparator","validQueryPart","parseQuery","s","parseQueryImpl","ex","message","decodeURIComponent","suite","fileString","testString","paramsString","split","undefined","parts","file","wildcard","filePathHasWildcard","parseBigPart","test","testPathHasWildcard","length","paramsParts","paramsHasWildcard","params","paramPart","k","v","parseSingleParam","kExampleQueries","separator","endsWithWildcard","i","part","entries","indexOf","paramSubstring","substring","parseSingleParamValue"],"mappings":"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","sourcesContent":["import {\n  CaseParamsRW,\n  ParamArgument,\n  badParamValueChars,\n  paramKeyIsPublic,\n} from '../params_utils.js';\nimport { assert } from '../util/util.js';\n\nimport { parseParamValue } from './json_param_value.js';\nimport {\n  TestQuery,\n  TestQueryMultiFile,\n  TestQueryMultiTest,\n  TestQueryMultiCase,\n  TestQuerySingleCase,\n} from './query.js';\nimport { kBigSeparator, kWildcard, kPathSeparator, kParamSeparator } from './separators.js';\nimport { validQueryPart } from './validQueryPart.js';\n\nexport function parseQuery(s: string): TestQuery {\n  try {\n    return parseQueryImpl(s);\n  } catch (ex) {\n    ex.message += '\\n  on: ' + s;\n    throw ex;\n  }\n}\n\nfunction parseQueryImpl(s: string): TestQuery {\n  // Undo encodeURIComponentSelectively\n  s = decodeURIComponent(s);\n\n  // bigParts are: suite, group, test, params (note kBigSeparator could appear in params)\n  const [suite, fileString, testString, paramsString] = s.split(kBigSeparator, 4);\n  assert(fileString !== undefined, `filter string must have at least one ${kBigSeparator}`);\n\n  const { parts: file, wildcard: filePathHasWildcard } = parseBigPart(fileString, kPathSeparator);\n\n  if (testString === undefined) {\n    // Query is file-level\n    assert(\n      filePathHasWildcard,\n      `File-level query without wildcard ${kWildcard}. Did you want a file-level query \\\n(append ${kPathSeparator}${kWildcard}) or test-level query (append ${kBigSeparator}${kWildcard})?`\n    );\n    return new TestQueryMultiFile(suite, file);\n  }\n  assert(!filePathHasWildcard, `Wildcard ${kWildcard} must be at the end of the query string`);\n\n  const { parts: test, wildcard: testPathHasWildcard } = parseBigPart(testString, kPathSeparator);\n\n  if (paramsString === undefined) {\n    // Query is test-level\n    assert(\n      testPathHasWildcard,\n      `Test-level query without wildcard ${kWildcard}; did you want a test-level query \\\n(append ${kPathSeparator}${kWildcard}) or case-level query (append ${kBigSeparator}${kWildcard})?`\n    );\n    assert(file.length > 0, 'File part of test-level query was empty (::)');\n    return new TestQueryMultiTest(suite, file, test);\n  }\n\n  // Query is case-level\n  assert(!testPathHasWildcard, `Wildcard ${kWildcard} must be at the end of the query string`);\n\n  const { parts: paramsParts, wildcard: paramsHasWildcard } = parseBigPart(\n    paramsString,\n    kParamSeparator\n  );\n\n  assert(test.length > 0, 'Test part of case-level query was empty (::)');\n\n  const params: CaseParamsRW = {};\n  for (const paramPart of paramsParts) {\n    const [k, v] = parseSingleParam(paramPart);\n    assert(validQueryPart.test(k), 'param key names must match ' + validQueryPart);\n    params[k] = v;\n  }\n  if (paramsHasWildcard) {\n    return new TestQueryMultiCase(suite, file, test, params);\n  } else {\n    return new TestQuerySingleCase(suite, file, test, params);\n  }\n}\n\n// webgpu:a,b,* or webgpu:a,b,c:*\nconst kExampleQueries = `\\\nwebgpu${kBigSeparator}a${kPathSeparator}b${kPathSeparator}${kWildcard} or \\\nwebgpu${kBigSeparator}a${kPathSeparator}b${kPathSeparator}c${kBigSeparator}${kWildcard}`;\n\nfunction parseBigPart(\n  s: string,\n  separator: typeof kParamSeparator | typeof kPathSeparator\n): { parts: string[]; wildcard: boolean } {\n  if (s === '') {\n    return { parts: [], wildcard: false };\n  }\n  const parts = s.split(separator);\n\n  let endsWithWildcard = false;\n  for (const [i, part] of parts.entries()) {\n    if (i === parts.length - 1) {\n      endsWithWildcard = part === kWildcard;\n    }\n    assert(\n      part.indexOf(kWildcard) === -1 || endsWithWildcard,\n      `Wildcard ${kWildcard} must be complete last part of a path (e.g. ${kExampleQueries})`\n    );\n  }\n  if (endsWithWildcard) {\n    // Remove the last element of the array (which is just the wildcard).\n    parts.length = parts.length - 1;\n  }\n  return { parts, wildcard: endsWithWildcard };\n}\n\nfunction parseSingleParam(paramSubstring: string): [string, ParamArgument] {\n  assert(paramSubstring !== '', 'Param in a query must not be blank (is there a trailing comma?)');\n  const i = paramSubstring.indexOf('=');\n  assert(i !== -1, 'Param in a query must be of form key=value');\n  const k = paramSubstring.substring(0, i);\n  assert(paramKeyIsPublic(k), 'Param in a query must not be private (start with _)');\n  const v = paramSubstring.substring(i + 1);\n  return [k, parseSingleParamValue(v)];\n}\n\nfunction parseSingleParamValue(s: string): ParamArgument {\n  assert(\n    !badParamValueChars.test(s),\n    `param value must not match ${badParamValueChars} - was ${s}`\n  );\n  return parseParamValue(s);\n}\n"],"file":"parseQuery.js"}